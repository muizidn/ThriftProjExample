/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

import Foundation

import Thrift


public enum Operation : TEnum {
  case add
  case subtract
  case multiply
  case divide
  case unknown(Int32)

  public static func read(from proto: TProtocol) throws -> Operation {
    let raw: Int32 = try proto.read()
    let new = Operation(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(Operation.self)")
    }
  }

  public init() {
    self = .add
  }

  public var rawValue: Int32 {
    switch self {
    case .add: return 1
    case .subtract: return 2
    case .multiply: return 3
    case .divide: return 4
    case .unknown(let value): return value
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 1: self = .add
    case 2: self = .subtract
    case 3: self = .multiply
    case 4: self = .divide
    default: self = .unknown(rawValue)
    }
  }
}

public typealias MyInteger = Int32

/// Structs are the basic complex data structures. They are comprised of fields
/// which each have an integer identifier, a type, a symbolic name, and an
/// optional default value.
/// Fields can be declared "optional", which ensures they will not be included
/// in the serialized output if they aren't set.  Note that this requires some
/// manual management in some languages.
public final class Work {

  public var num1: Int32

  public var num2: Int32

  public var op: Operation

  public var comment: String?


  public init(num1: Int32, num2: Int32, op: Operation) {
    self.num1 = num1
    self.num2 = num2
    self.op = op
  }

  public init(num1: Int32, num2: Int32, op: Operation, comment: String?) {
    self.num1 = num1
    self.num2 = num2
    self.op = op
    self.comment = comment
  }

}

/// Structs can also be exceptions, if they are nasty.
public final class InvalidOperation : Swift.Error {

  public var whatOp: Int32

  public var why: String


  public init(whatOp: Int32, why: String) {
    self.whatOp = whatOp
    self.why = why
  }

}

/// Ahh, now onto the cool part, defining a service. Services just need a name
/// and can optionally inherit from another service using the extends keyword.
public protocol Calculator : SharedService {

  /// A method definition looks like C code. It has a return type, arguments,
  /// and optionally a list of exceptions that it may throw. Note that argument
  /// lists and exception lists are specified using the exact same syntax as
  /// field lists in struct or exception definitions.
  ///
  /// - Throws: 
  func ping() throws

  ///
  /// - Parameters:
  ///   - num1: 
  ///   - num2: 
  /// - Returns: Int32
  /// - Throws: 
  func add(num1: Int32, num2: Int32) throws -> Int32

  ///
  /// - Parameters:
  ///   - logid: 
  ///   - w: 
  /// - Returns: Int32
  /// - Throws: InvalidOperation
  func calculate(logid: Int32, w: Work) throws -> Int32

  /// This method has a oneway modifier. That means the client only makes
  /// a request and does not listen for any response at all. Oneway methods
  /// must be void.
  ///
  /// - Throws: 
  func zip() throws

}

open class CalculatorClient : SharedServiceClient /* , Calculator */ {

}

open class CalculatorProcessor /* Calculator */ {

  typealias ProcessorHandlerDictionary = [String: (Int32, TProtocol, TProtocol, Calculator) throws -> Void]

  public var service: Calculator

  public required init(service: Calculator) {
    self.service = service
  }

}

public let INT32CONSTANT : Int32 = Int32(9853)

public let MAPCONSTANT : TMap<String, String> = ["goodnight": "moon", "hello": "world"]


