/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

import Foundation

import Thrift


public func ==(lhs: Work, rhs: Work) -> Bool {
  return
    (lhs.num1 == rhs.num1) &&
    (lhs.num2 == rhs.num2) &&
    (lhs.op == rhs.op) &&
    (lhs.comment == rhs.comment)
}

extension Work : CustomStringConvertible {

  public var description : String {
    var desc = "Work("
    desc += "num1=\(String(describing: self.num1)), "
    desc += "num2=\(String(describing: self.num2)), "
    desc += "op=\(String(describing: self.op)), "
    desc += "comment=\(String(describing: self.comment))"
    return desc
  }

}

extension Work : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (num1.hashValue)
    result = prime &* result &+ (num2.hashValue)
    result = prime &* result &+ (op.hashValue)
    result = prime &* result &+ (comment?.hashValue ?? 0)
    return result
  }

}

extension Work : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["num1": 1, "num2": 2, "op": 3, "comment": 4, ]
  }

  public static var structName: String { return "Work" }

  public static func read(from proto: TProtocol) throws -> Work {
    _ = try proto.readStructBegin()
    var num1: Int32!
    var num2: Int32!
    var op: Operation!
    var comment: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             num1 = try Int32.read(from: proto)
        case (2, .i32):             num2 = try Int32.read(from: proto)
        case (3, .i32):             op = try Operation.read(from: proto)
        case (4, .string):           comment = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(num1, named: "num1")
    try proto.validateValue(num2, named: "num2")
    try proto.validateValue(op, named: "op")

    return Work(num1: num1, num2: num2, op: op, comment: comment)
  }

}



public func ==(lhs: InvalidOperation, rhs: InvalidOperation) -> Bool {
  return
    (lhs.whatOp == rhs.whatOp) &&
    (lhs.why == rhs.why)
}

extension InvalidOperation : CustomStringConvertible {

  public var description : String {
    var desc = "InvalidOperation("
    desc += "whatOp=\(String(describing: self.whatOp)), "
    desc += "why=\(String(describing: self.why))"
    return desc
  }

}

extension InvalidOperation : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (whatOp.hashValue)
    result = prime &* result &+ (why.hashValue)
    return result
  }

}

extension InvalidOperation : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["whatOp": 1, "why": 2, ]
  }

  public static var structName: String { return "InvalidOperation" }

  public static func read(from proto: TProtocol) throws -> InvalidOperation {
    _ = try proto.readStructBegin()
    var whatOp: Int32!
    var why: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             whatOp = try Int32.read(from: proto)
        case (2, .string):           why = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(whatOp, named: "whatOp")
    try proto.validateValue(why, named: "why")

    return InvalidOperation(whatOp: whatOp, why: why)
  }

}



fileprivate final class Calculator_ping_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Calculator_ping_args, rhs: Calculator_ping_args) -> Bool {
  return true
}

extension Calculator_ping_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension Calculator_ping_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Calculator_ping_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Calculator_ping_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Calculator_ping_args()
  }

}



fileprivate final class Calculator_ping_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Calculator_ping_result, rhs: Calculator_ping_result) -> Bool {
  return true
}

extension Calculator_ping_result : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension Calculator_ping_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Calculator_ping_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Calculator_ping_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Calculator_ping_result()
  }

}



fileprivate final class Calculator_add_args {

  fileprivate var num1: Int32

  fileprivate var num2: Int32


  fileprivate init(num1: Int32, num2: Int32) {
    self.num1 = num1
    self.num2 = num2
  }

}

fileprivate func ==(lhs: Calculator_add_args, rhs: Calculator_add_args) -> Bool {
  return
    (lhs.num1 == rhs.num1) &&
    (lhs.num2 == rhs.num2)
}

extension Calculator_add_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (num1.hashValue)
    result = prime &* result &+ (num2.hashValue)
    return result
  }

}

extension Calculator_add_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["num1": 1, "num2": 2, ]
  }

  fileprivate static var structName: String { return "Calculator_add_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Calculator_add_args {
    _ = try proto.readStructBegin()
    var num1: Int32!
    var num2: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             num1 = try Int32.read(from: proto)
        case (2, .i32):             num2 = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(num1, named: "num1")
    try proto.validateValue(num2, named: "num2")

    return Calculator_add_args(num1: num1, num2: num2)
  }

}



fileprivate final class Calculator_add_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Calculator_add_result, rhs: Calculator_add_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Calculator_add_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    return result
  }

}

extension Calculator_add_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Calculator_add_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Calculator_add_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Calculator_add_result(success: success)
  }

}



fileprivate final class Calculator_calculate_args {

  fileprivate var logid: Int32

  fileprivate var w: Work


  fileprivate init(logid: Int32, w: Work) {
    self.logid = logid
    self.w = w
  }

}

fileprivate func ==(lhs: Calculator_calculate_args, rhs: Calculator_calculate_args) -> Bool {
  return
    (lhs.logid == rhs.logid) &&
    (lhs.w == rhs.w)
}

extension Calculator_calculate_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (logid.hashValue)
    result = prime &* result &+ (w.hashValue)
    return result
  }

}

extension Calculator_calculate_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["logid": 1, "w": 2, ]
  }

  fileprivate static var structName: String { return "Calculator_calculate_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Calculator_calculate_args {
    _ = try proto.readStructBegin()
    var logid: Int32!
    var w: Work!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             logid = try Int32.read(from: proto)
        case (2, .struct):           w = try Work.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(logid, named: "logid")
    try proto.validateValue(w, named: "w")

    return Calculator_calculate_args(logid: logid, w: w)
  }

}



fileprivate final class Calculator_calculate_result {

  fileprivate var success: Int32?

  fileprivate var ouch: InvalidOperation?


  fileprivate init() { }
  fileprivate init(success: Int32?, ouch: InvalidOperation?) {
    self.success = success
    self.ouch = ouch
  }

}

fileprivate func ==(lhs: Calculator_calculate_result, rhs: Calculator_calculate_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.ouch == rhs.ouch)
}

extension Calculator_calculate_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (ouch?.hashValue ?? 0)
    return result
  }

}

extension Calculator_calculate_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "ouch": 1, ]
  }

  fileprivate static var structName: String { return "Calculator_calculate_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Calculator_calculate_result {
    _ = try proto.readStructBegin()
    var success: Int32?
    var ouch: InvalidOperation?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case (1, .struct):           ouch = try InvalidOperation.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Calculator_calculate_result(success: success, ouch: ouch)
  }

}



fileprivate final class Calculator_zip_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Calculator_zip_args, rhs: Calculator_zip_args) -> Bool {
  return true
}

extension Calculator_zip_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension Calculator_zip_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Calculator_zip_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Calculator_zip_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Calculator_zip_args()
  }

}



extension CalculatorClient : Calculator {

  private func send_ping() throws {
    try outProtocol.writeMessageBegin(name: "ping", type: .call, sequenceID: 0)
    let args = Calculator_ping_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_ping() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Calculator_ping_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func ping() throws {
    try send_ping()
    try outProtocol.transport.flush()
    try recv_ping()
  }

  private func send_add(num1: Int32, num2: Int32) throws {
    try outProtocol.writeMessageBegin(name: "add", type: .call, sequenceID: 0)
    let args = Calculator_add_args(num1: num1, num2: num2)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_add() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Calculator_add_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "add"))
  }

  public func add(num1: Int32, num2: Int32) throws -> Int32 {
    try send_add(num1: num1, num2: num2)
    try outProtocol.transport.flush()
    return try recv_add()
  }

  private func send_calculate(logid: Int32, w: Work) throws {
    try outProtocol.writeMessageBegin(name: "calculate", type: .call, sequenceID: 0)
    let args = Calculator_calculate_args(logid: logid, w: w)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_calculate() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Calculator_calculate_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let ouch = result.ouch {
      throw ouch
    }
    throw TApplicationError(error: .missingResult(methodName: "calculate"))
  }

  public func calculate(logid: Int32, w: Work) throws -> Int32 {
    try send_calculate(logid: logid, w: w)
    try outProtocol.transport.flush()
    return try recv_calculate()
  }

  private func send_zip() throws {
    try outProtocol.writeMessageBegin(name: "zip", type: .oneway, sequenceID: 0)
    let args = Calculator_zip_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  public func zip() throws {
    try send_zip()
    try outProtocol.transport.flush()
  }

}

extension CalculatorProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["ping"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Calculator_ping_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Calculator_ping_result()
      do {
        try handler.ping()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "ping", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["add"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Calculator_add_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Calculator_add_result()
      do {
        result.success = try handler.add(num1: args.num1, num2: args.num2)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "add", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["calculate"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Calculator_calculate_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Calculator_calculate_result()
      do {
        result.success = try handler.calculate(logid: args.logid, w: args.w)
      }
      catch let error as InvalidOperation { result.ouch = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "calculate", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["zip"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Calculator_zip_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = CalculatorProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

